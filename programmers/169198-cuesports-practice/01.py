# 구하는거: [공이 굴러간 거리의 최솟값의 제곱]
# 경우의 수를 나눠보자
#   1. x좌표가 같고 y좌표가 다를 때
#   2. x좌표가 다르고 y좌표가 같을 때
#   3. x좌표도 다르고 y좌표도 다를 때
# 경우의 수마다 생각해보자
#   1 => 윗벽이나 아랫벽에 쳐서 맞추는 게 가장 최소임
#   2 => 왼쪽벽이나 오른쪽벽에 쳐서 맞추는 게 가장 최소임
#   3 => 어디 벽을 칠 지가 포인트인데...
# 일반화로 생각해보자
#   공이 칠 공을 x나 y축을 기준으로 반전시킨다
#   머쓱-좌가 칠 공과 반전시킨 점을 연결하면 그게 길이의 합
#   그럼 어디 벽을 칠 지만 알면 된다.
#   그냥 다 해보고 작은 거 고르면 되지~
#     그러면 안됐다... 1번 케이스의 2번이 반례
#     최소거리는 왼쪽벽을 치는 건데, 칠 공이 오른쪽에 있기 때문에 그럴 수 없음 (벽 전에 공을 먼저 침)
#     일직선으로 선을 그었을 때 머쓱공이 안쪽에 있으면 그쪽 벽으로는 못 침
#     안되는 경우는 빼주자
def solution(m, n, startX, startY, balls):
    """
    m, n = 당구대의 가로, 세로 길이
    startX, startY = 머-쓱이가 칠 공이 놓인 위치좌표 (원점은 좌측하단)
    balls = 공으로 쳐야하는 공이 놓인 좌표
    """
    def 거리(a, b):
        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2
    
    def 왼쪽벽치기(머쓱공, 칠공):
        칠공 = (-칠공[0], 칠공[1])
        return 거리(머쓱공, 칠공)
    
    def 아래벽치기(머쓱공, 칠공):
        칠공 = (칠공[0], -칠공[1])
        return 거리(머쓱공, 칠공)
    
    def 오른벽치기(머쓱공, 칠공):
        칠공 = ((m - 칠공[0]) * 2 + 칠공[0], 칠공[1])
        return 거리(머쓱공, 칠공)
    
    def 윗벽치기(머쓱공, 칠공):
        칠공 = (칠공[0], (n - 칠공[1]) * 2 + 칠공[1])
        return 거리(머쓱공, 칠공)
    
    def all_cases(머쓱공, 칠공):
        max = n ** 2 + m ** 2
        return [
            윗벽치기(머쓱공, 칠공) if not (머쓱공[0] == 칠공[0] and 머쓱공[1] < 칠공[1]) else max,
            아래벽치기(머쓱공, 칠공) if not (머쓱공[0] == 칠공[0] and 머쓱공[1] > 칠공[1]) else max,
            오른벽치기(머쓱공, 칠공) if not (머쓱공[1] == 칠공[1] and 머쓱공[0] < 칠공[0]) else max,
            왼쪽벽치기(머쓱공, 칠공) if not (머쓱공[1] == 칠공[1] and 머쓱공[0] > 칠공[0]) else max,
        ]
    
    return [min(all_cases((startX, startY), (x, y))) for x, y in balls]
